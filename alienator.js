import Alien from "./alien.js"

// NOTES:
// - I think makeValidHslColors() and especially getNearestHslColor() was an interesting thing to do
//   and I may use this in another project, but I think if I want to redo the colour picker
//   I rather write a HSL picker that is generated by code and selects colours by angle and distance
//   to the center. For now reading the bitmap pixel colour works fine but isn't ideal because
//   of antialiasing where two colours meet. But it's super flexible because you can just swap out
//   the colour picker image.

// TO DO:
// - some combinations (~30 or so) son't work that well. Maybe create handcrafted ones of those and if they exist use the handcrafted version.
// - handcrafted version needs to store where head and body are to place eyes
// - the random colours don't seem to show yellow tones, why?
// - eyes need to be draggable (and only onto the body, maybe I need a
//   second inner shape and eyes can only drop if inside of that shape)
// - draggable eyes should not overlap each other
// - still, for the random generator we need a way to automatically place eyes,
//   ideally with a random placement on the shape with validation as user drag and drop;
//   maybe a while loop that picks random positions within the body part bounds and places
//   the eye as long as it does not collide with other eyes; but limit the number of loops
//   because it's possible that there's just no space left, and I don't think there's a
//   simple way to check that
// - eyes on the body should be permitted, however, the random generator should prioritise
//   to place them on the head
// - 2 eyes should be prioritised on the same height
// - save as an image on the server (maybe even png and gif with eye blink)
// - save user info in the database
//   alien table: ( id, timestamp, name, 2 traits, dna: headID, bodyID, color)
// - eyes table (links to aliens table via id): ( id, alienID, eyeID, x, y, eyeTick?, scale? )
// - display aliens as images
// - maybe also display aliens moving across the screen

const game = new Phaser.Game( 1200, 1200, Phaser.CANVAS, '', { preload: preload, create: create, update: update } )

let alien
let colorSelector
let validHslColors
let validColors
let ui


function preload () {
  game.load.atlas( 'assets', 'assets/assets.png', 'assets/assets.json', Phaser.Loader.TEXTURE_ATLAS_JSON_HASH )
}


function create () {
  console.log( 'GAME', game )

  const alienOffsetY = -80

  game.input.maxPointers = 1
  game.stage.backgroundColor = 0xffffff
  game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL
  game.scale.parentIsWindow = true

  const dna = hashToDNA()

  const x = game.world.centerX
  const y = game.world.centerY + alienOffsetY
  alien = new Alien( { game, x, y, mutable: true, dna, onMake: dnaToHash } )
  console.log( 'ALIEN', alien )

  validHslColors = makeValidHslColors()
  validColors = _.map( validHslColors, ( hsl ) => Phaser.Color.HSLtoRGB( hsl.s, hsl.s, hsl.l ) )

  ui = makeUI( { previousNextButtonOffsetY: alienOffsetY } )

  game.input.keyboard.addKey( Phaser.Keyboard.DOWN ).onDown.add( () => alien.showPreviousItem( { type: 'body' } ) )
  game.input.keyboard.addKey( Phaser.Keyboard.UP ).onDown.add( () => alien.showNextItem( { type: 'body' } ) )
  game.input.keyboard.addKey( Phaser.Keyboard.LEFT ).onDown.add( () => alien.showPreviousItem( { type: 'head' } ) )
  game.input.keyboard.addKey( Phaser.Keyboard.RIGHT ).onDown.add( () => alien.showNextItem( { type: 'head' } ) )
  game.input.keyboard.addKey( Phaser.Keyboard.SPACEBAR ).onDown.add( () => alien.randomize() )
}


function hashToDNA ( opt ) {
  const { separator1, separator2, mapping } = _.defaults( opt || {}, {
    separator1: ',',
    separator2: '=',
    mapping: {
      body: 'bodyID',
      head: 'headID',
      eye: 'eyeID',
      color: 'color',
    },
  } )

  const hash = window.location.hash.replace( /^\#/, '' )

  return _.fromPairs( _.remove( _.forEach( _.map( hash.split( separator1 ), ( part ) => part.split( separator2 ) ), ( pair ) => {
    pair[ 0 ] = mapping[ pair[ 0 ] ]
    if ( !isNaN( _.toNumber( pair[ 1 ] ) ) ) pair[ 1 ] = _.toNumber( pair[ 1 ] )
  } ), ( pair ) => pair[ 0 ] !== undefined ) )
}


function dnaToHash ( opt ) {
  const { dna, separator1, separator2, mapping } = _.defaults( opt || {}, {
    separator1: ',',
    separator2: '=',
    mapping: {
      body: 'bodyID',
      head: 'headID',
      eye: 'eyeID',
      color: 'color',
    },
  } )

  const hash = _.join( _.map( _.forEach( _.toPairs( dna ), ( pair ) => {
    if ( pair[ 0 ] === mapping.color ) pair[ 1 ] = `0x${ pair[ 1 ].toString( 16 ) }`
    pair[ 0 ] = _.findKey( mapping, ( item ) => item === pair[ 0 ] )
  } ), ( pair ) => _.join( pair, separator2 ) ), separator1 )

  window.location.hash = hash

  return hash
}


function makeUI ( opt = {} ) {
  const { edgeMargin, headYPosFactor, bodyYPosFactor, previousNextButtonOffsetY, randomXPosFactor, doneXPosFactor } = _.defaults( opt, {
    edgeMargin: 30,
    headYPosFactor: 0.4,
    bodyYPosFactor: 0.6,
    previousNextButtonOffsetY: 0,
  } )

  const group = game.add.group()
  const bounds = game.world.bounds

  colorSelector = makeColorSelector( { parent: group } )
  colorSelector.sprite.position.set( bounds.centerX, bounds.bottom - colorSelector.height / 2 - edgeMargin )

  const random = game.add.button( 0, 0, 'assets', () => alien.randomize(), this, 'uiRandomOver', 'uiRandom', 'uiRandomDown', 'uiRandom', group )
  random.anchor.set( 0.5, 0.5 )
  random.position.set( bounds.left + random.width / 2 + edgeMargin, colorSelector.sprite.y  )
  group.randomButton = random

  const done = game.add.button( 0, 0, 'assets', () => window.alert( 'I can\'t do that yet.' ), this, 'uiDoneOver', 'uiDone', 'uiDoneDown', 'uiDone', group )
  done.anchor.set( 0.5, 0.5 )
  done.position.set( bounds.right - done.width / 2 - edgeMargin, colorSelector.sprite.y )
  group.doneButton = done

  const previousHead = game.add.button( 0, 0, 'assets', () => alien.showPreviousItem( { type: 'head' } ), this, 'uiPreviousOver', 'uiPrevious', 'uiPreviousDown', 'uiPrevious', group )
  previousHead.anchor.set( 0.5, 0.5 )
  previousHead.position.set( bounds.left + random.width / 2 + edgeMargin, bounds.height * headYPosFactor + previousNextButtonOffsetY )
  group.previousHeadButton = previousHead

  const previousBody = game.add.button( 0, 0, 'assets', () => alien.showPreviousItem( { type: 'body' } ), this, 'uiPreviousOver', 'uiPrevious', 'uiPreviousDown', 'uiPrevious', group )
  previousBody.anchor.set( 0.5, 0.5 )
  previousBody.position.set( bounds.left + random.width / 2 + edgeMargin, bounds.height * bodyYPosFactor + previousNextButtonOffsetY )
  group.previousBodyButton = previousBody

  const nextHead = game.add.button( 0, 0, 'assets', () => alien.showNextItem( { type: 'head' } ), this, 'uiNextOver', 'uiNext', 'uiNextDown', 'uiNext', group )
  nextHead.anchor.set( 0.5, 0.5 )
  nextHead.position.set( bounds.right - random.width / 2 - edgeMargin, bounds.height * headYPosFactor + previousNextButtonOffsetY )
  group.nextHeadButton = nextHead

  const nextBody = game.add.button( 0, 0, 'assets', () => alien.showNextItem( { type: 'body' } ), this, 'uiNextOver', 'uiNext', 'uiNextDown', 'uiNext', group )
  nextBody.anchor.set( 0.5, 0.5 )
  nextBody.position.set( bounds.right - random.width / 2 - edgeMargin, bounds.height * bodyYPosFactor + previousNextButtonOffsetY )
  group.nextButton = nextBody

  return group
}


function makeColorSelector ( opt = {} ) {
  const { parent, x, y } = _.defaults( opt, {
    x: 0,
    y: 0,
  } )

  const image = game.make.image( 0, 0, 'assets', 'colorPicker' )
  const bmd = game.make.bitmapData( image.width, image.height )
  bmd.draw( image, x, y )
  bmd.update()
  const sprite = bmd.addToWorld()
  sprite.anchor.set( 0.5, 0.5 )
  bmd.sprite = sprite
  parent.add( sprite )
  game.input.addMoveCallback( getColor )
  return bmd

  function getColor ( pointer ) {
    const { x, y } = pointer

    const posX = Math.round( x - sprite.x + sprite.anchor.x * sprite.width )
    const posY = Math.round( y - sprite.y + sprite.anchor.y * sprite.height )

    if ( pointer.isDown && posX >= 0 && posX <= bmd.width && posY >= 0 && posY <= bmd.height ) {
      const rgb = bmd.getPixelRGB( posX, posY )
      const color = Phaser.Color.getColor( rgb.r, rgb.g, rgb.b )

      if ( rgb.a === 255 && color !== alien.dna.color ) {
        alien.setColor( { color } )
      }
    }
  }
}


function makeValidHslColors ( opt = {} ) {
  const {
    hueSteps, saturationSteps, luminositySteps,
    hueMin, hueMax, hueEase,
    saturationMin, saturationMax, saturationEase,
    luminosityMin, luminosityMax, luminosityEase,
    extraColors, log,
  } = _.defaults( opt, {
    hueSteps: 24,
    hueMin: 0,
    hueMax: 1,
    hueEase: Linear.easeNone,
    saturationSteps: 7,
    saturationMin: 0.5,
    saturationMax: 0.85,
    saturationEase: Linear.easeNone,
    luminositySteps: 7,
    luminosityMin: 0.4,
    luminosityMax: 0.85,
    luminosityEase: Linear.easeNone,
    extraColors: [ 0x000000, 0xffffff ],
    log: false,
  } )

  const luminositySaturationSteps = Math.max( luminositySteps, saturationSteps )

  const extraHslColors = _.map( extraColors, ( color ) => {
    const rgb = Phaser.Color.getRGB( color )
    const hsl = Phaser.Color.RGBtoHSL( rgb.r, rgb.g, rgb.b )
    return hsl
  } )

  const colors = extraHslColors || []

  let i = 0

  for ( const hueStep of _.range( hueSteps ) ) {
    const h = hueMin + Math.abs( hueMax - hueMin ) * hueEase( ( hueStep / hueSteps ) )

    for ( const luminositySaturationStep of _.range( luminositySaturationSteps ) ) {
      const s = saturationMin + Math.abs( saturationMax - saturationMin ) * saturationEase( luminositySaturationStep / luminositySaturationSteps )
      const l = luminosityMin + Math.abs( luminosityMax - luminosityMin ) * luminosityEase( luminositySaturationStep / luminositySaturationSteps )

      const rgb = Phaser.Color.HSLtoRGB( h, s, l )
      const color = _.merge( rgb, { h, s, l } )
      colors.push( color )

      if ( log ) {
        const colorString = Phaser.Color.RGBtoString( rgb.r, rgb.g, rgb.b )
        console.log( `%c ${ i++ }: ${ h }, ${ s }, ${ l }, ${ rgb.color }`, `background: ${ colorString }; color: #000000` )
      }
    }
  }

  return colors
}


function update() {
}
